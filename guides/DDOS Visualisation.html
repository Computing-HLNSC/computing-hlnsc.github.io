<!DOCTYPE html>
<html lang="en">
  <head id="head">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computing Department | Cisco Networking Academy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      #content {
        display: flex;
        justify-content: center;
        width: 100%;
      }

      #simulation {
        width: 70%;
        margin-right: 0%;
      }

      #console-container {
        width: 30%;
        margin-right: 0%;
      }

      #console {
        width: 100%;
        height: 500px;
        border: 1px solid #000;
        overflow-y: scroll;
        padding: 10px;
        font-size: 14px;
        line-height: 1.4;
        scrollbar-width: none;
        /* Firefox */
        -ms-overflow-style: none;
        /* Internet Explorer 10+ */
      }

      #console::-webkit-scrollbar {
        display: none;
        /* Safari and Chrome */
      }

      .tooltip {
        position: relative;
        display: inline-block;
        border-bottom: 1px dotted black;
      }

      .tooltip .tooltiptext {
        visibility: hidden;
        width: 220px;
        background-color: #555;
        color: #fff;
        text-align: center;
        border-radius: 6px;
        padding: 5px;
        position: fixed;
        /* Changed from absolute to fixed */
        z-index: 1000;
        /* Ensure the tooltip is above other elements */
        opacity: 0;
        transition: opacity 0.3s;
      }

      .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
      }

      #map {
        width: 95%;
        height: 500px;
        border: 1px solid #000;
        background: url(../guides/images/ddosvis/map.svg) no-repeat center;
        background-size: cover;
        position: relative;
      }

      #coordinates-tooltip {
        visibility: hidden;
        width: 120px;
        background-color: #555;
        color: #fff;
        text-align: center;
        border-radius: 6px;
        padding: 5px;
        position: fixed;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.3s;
      }

      canvas {
        position: absolute;
        left: 0;
        top: 0;
      }

      #controls {
        margin: 20px 0;
        text-align: center;
      }

      .vis_button {
        padding: 10px 20px;
        font-size: 16px;
        margin: 5px;
        border: solid 1px;
      }

      .vis_button:hover{
        background:rgba(0, 0, 0, 0.2);
      }

      .fontstyling {
        font-family: Impact, Charcoal, sans-serif;
        font-size: 31px;
        letter-spacing: 0px;
        word-spacing: 2px;
        color: #000000;
        font-weight: 400;
        text-decoration: none;
        font-style: normal;
        font-variant: small-caps;
        text-transform: none;
      }
    </style>
  </head>
  <body class="bg-[#0D3B66] font-sans">
    <div id="header"></div>
    <div id="imodal"></div>
    <section class="py-3">
      <div class="container mx-auto px-4">
        <div class="bg-white shadow-lg rounded-lg p-6">
          <h2 class="text-l font-bold mb-4 p-2">
            <a class="bg-gray-200 p-2 w-40 text-left" href="../index.html">üè† Return Home</a>
            <a class="bg-gray-200 p-2">Distributed Denial of Service (Visualisation)</a>
          </h2>
          <hr>
          <br>
          <div id="chapters" class="">
            <!-- Chapter 1:  -->
            <section class="chapter" id="chapter-one" data-chapter="chapter-one">
              <div id="stepsWrapper-chapter-one" class="">
                  <div id="content">
                    <div id="simulation">
                      <h2 class="fontstyling" style="text-align: center;">World Map</h2>
                      <center>
                        <div id="map">
                          <canvas id="canvas"></canvas>
                          <!--<div id="coordinates-tooltip"></div>  Tooltip for coordinates -->
                        </div>
                      </center>
                      <div id="controls">
                        <button class="vis_button" onclick="toggleNodes()">Toggle Nodes</button>
                        <button class="vis_button" onclick="toggleNetworkTraffic()">Toggle Network Traffic</button>
                        <button class="vis_button" onclick="startSimulation()">Start Simulation</button>
                        <button class="vis_button" onclick="resetSimulation()">Reset Simulation</button>
                      </div>
                    </div>
                    <div id="console-container">
                      <h2 class="fontstyling" style="text-align: center;">Network Traffic</h2>
                      <div id="console">
                        <div id="log"></div>
                      </div>
                    </div>
                  </div>
                  <script>
                    // Predefined coordinates for the DDoS attack
                    const coordinates = [
                      { x: 32.97, y: 52.31 },
                      { x: 121.97, y: 37.31 },
                      { x: 287.97, y: 20.31 },
                      { x: 411.97, y: 95.31 },
                      { x: 401.97, y: 158.31 },
                      { x: 247.97, y: 228.31 },
                      { x: 253.97, y: 350.31 },
                      { x: 168.97, y: 480.31 },
                      { x: 703.97, y: 317.31 },
                      { x: 761.97, y: 339.31 },
                      { x: 693.97, y: 239.31 },
                      { x: 610.97, y: 134.31 },
                      { x: 630.97, y: 62.31 },
                      { x: 798.97, y: 55.31 },
                      { x: 462.97, y: 52.31 },
                      { x: 471.97, y: 287.31 },
                      { x: 220.97, y: 139.31 },
                      { x: 132.97, y: 131.31 },
                      { x: 496.97, y: 201.31 },
                      { x: 670.97, y: 199.31 },
                    ];
                    let animationFrameId;
                    let nodesVisible = false; // Nodes are hidden by default
                    let targetNode = coordinates[0]; // Default target node
                    let trafficVisible = false; // Network traffic is hidden by default
                    let trafficIntervalId;
                    let trafficAnimations = []; // Array to hold traffic animation functions
                    // Function to draw a line segment incrementally
                    function drawLineSegment(ctx, startX, startY, endX, endY, progress) {
                      const currentX = startX + (endX - startX) * progress;
                      const currentY = startY + (endY - startY) * progress;
                      ctx.beginPath();
                      ctx.moveTo(startX, startY);
                      ctx.lineTo(currentX, currentY);
                      ctx.strokeStyle = 'red';
                      ctx.lineWidth = 2;
                      ctx.setLineDash([3, 3]); // Set line dash pattern
                      ctx.stroke();
                      ctx.setLineDash([]); // Reset line dash pattern
                    }
                    // Function to generate random packet data
                    function generateRandomPacketData() {
                      const packetTypes = ['HTTP Request', 'DNS Query', 'TCP Handshake', 'UDP Packet', 'ICMP Ping'];
                      const packetType = packetTypes[Math.floor(Math.random() * packetTypes.length)];
                      const packetSize = Math.floor(Math.random() * 1500) + 64; // Packet size between 64 and 1564 bytes
                      const latency = Math.floor(Math.random() * 100) + 1; // Latency between 1 and 100 ms
                      return `${packetType} - Size: ${packetSize} bytes, Latency: ${latency} ms`;
                    }
                    // Function to generate random packet data and additional packet information
                    function generatePacketDataAndInfo() {
                      const packetTypes = ['HTTP Request', 'DNS Query', 'TCP Handshake', 'UDP Packet', 'ICMP Ping'];
                      const sources = ['192.168.0.1', '10.0.0.2', '172.16.0.3'];
                      const destinations = ['203.0.113.1', '203.0.113.2', '203.0.113.3'];
                      const ports = [80, 443, 53, 123, 8080];
                      const packetSize = Math.floor(Math.random() * 1500) + 64; // Packet size between 64 and 1564 bytes
                      const latency = Math.floor(Math.random() * 100) + 1; // Latency between 1 and 100 ms
                      const packetType = packetTypes[Math.floor(Math.random() * packetTypes.length)];
                      const source = sources[Math.floor(Math.random() * sources.length)];
                      const destination = destinations[Math.floor(Math.random() * destinations.length)];
                      const sourcePort = ports[Math.floor(Math.random() * ports.length)];
                      const destinationPort = ports[Math.floor(Math.random() * ports.length)];
                      const packetData = `${packetType} - Size: ${packetSize} bytes, Latency: ${latency} ms`;
                      const additionalInfo = `Source: ${source}
															<br>Destination: ${destination}
																<br>Source Port: ${sourcePort}
																	<br>Destination Port: ${destinationPort}
																		<br>Payload Size: ${packetSize} bytes`;
                      return {
                        packetData,
                        additionalInfo
                      };
                    }
                    // Function to log traffic events to the console with tooltips for additional packet information
                    function logTrafficEvent(startNode, endNode) {
                      const logElement = document.getElementById('log');
                      const {
                        packetData,
                        additionalInfo
                      } = generatePacketDataAndInfo(); // Generate packet data and additional info
                      const logMessage = `Node ${startNode} -> Node ${endNode}: ${packetData}`;
                      const newLogEntry = document.createElement('div');
                      newLogEntry.classList.add('tooltip');
                      newLogEntry.textContent = logMessage;
                      // Create tooltip text
                      const tooltipText = document.createElement('span');
                      tooltipText.classList.add('tooltiptext');
                      tooltipText.innerHTML = additionalInfo;
                      newLogEntry.appendChild(tooltipText);
                      newLogEntry.onmousemove = function(event) {
                        tooltipText.style.top = `${event.clientY + 10}px`; // Position 10px below the cursor
                        tooltipText.style.left = `${event.clientX + 10}px`; // Position 10px to the right of the cursor
                      };
                      logElement.appendChild(newLogEntry);
                      // Scroll to the bottom of the log
                      const consoleElement = document.getElementById('console');
                      consoleElement.scrollTop = consoleElement.scrollHeight;
                    }
                    // Function to show coordinates on map
                    function showCoordinates(event) {
                      const mapElement = document.getElementById('map');
                      const tooltip = document.getElementById('coordinates-tooltip');
                      const rect = mapElement.getBoundingClientRect();
                      const x = event.clientX - rect.left;
                      const y = event.clientY - rect.top;
                      tooltip.style.top = `${event.clientY + 10}px`;
                      tooltip.style.left = `${event.clientX + 10}px`;
                      tooltip.innerHTML = `X: ${x.toFixed(2)}, Y: ${y.toFixed(2)}`;
                      tooltip.style.visibility = 'visible';
                      tooltip.style.opacity = '1';
                      // Store the current coordinates for potential copying
                      mapElement.dataset.currentX = x.toFixed(2);
                      mapElement.dataset.currentY = y.toFixed(2);
                    }
                    // Function to hide coordinates tooltip
                    function hideCoordinates() {
                      const tooltip = document.getElementById('coordinates-tooltip');
                      tooltip.style.visibility = 'hidden';
                      tooltip.style.opacity = '0';
                    }
                    // Function to copy coordinates to clipboard
                    function copyCoordinates(event) {
                      const mapElement = document.getElementById('map');
                      if (event.key === 'c' || event.key === 'C') {
                        const x = mapElement.dataset.currentX;
                        const y = mapElement.dataset.currentY;
                        const coordinateText = `{ x: ${x}, y: ${y} },`;
                        navigator.clipboard.writeText(coordinateText).then(() => {
                          //alert(`Copied to clipboard: ${coordinateText}`);
                        });
                      }
                    }
                    // Add event listeners for showing coordinates and copying them
                    const mapElement = document.getElementById('map');
                    mapElement.addEventListener('mousemove', showCoordinates);
                    mapElement.addEventListener('mouseleave', hideCoordinates);
                    document.addEventListener('keydown', copyCoordinates);
                    // Function to draw nodes
                    function drawNodes(ctx, coordinates, target) {
                      if (nodesVisible) {
                        coordinates.forEach(({
                          x,
                          y
                        }) => {
                          ctx.beginPath();
                          ctx.arc(x, y, 5, 0, 2 * Math.PI, false);
                          ctx.fillStyle = 'green';
                          ctx.fill();
                        });
                        ctx.beginPath();
                        ctx.arc(target.x, target.y, 5, 0, 2 * Math.PI, false);
                        ctx.fillStyle = 'orange';
                        ctx.fill();
                      }
                    }
                    // Function to simulate DDoS attack by animating multiple lines to a single target
                    function startSimulation() {
                      // Stop the normal network traffic when the simulation starts
                      if (trafficIntervalId) {
                        clearInterval(trafficIntervalId);
                        trafficVisible = false;
                      }
                      // Log the start of the DDoS simulation
                      const logElement = document.getElementById('log');
                      const logMessage = 'Starting DDoS Simulation...';
                      const newLogEntry = document.createElement('div');
                      newLogEntry.textContent = logMessage;
                      logElement.appendChild(newLogEntry);
                      logElement.scrollTop = logElement.scrollHeight;
                      const mapElement = document.getElementById('map');
                      const canvas = document.getElementById('canvas');
                      const ctx = canvas.getContext('2d');
                      canvas.width = mapElement.clientWidth;
                      canvas.height = mapElement.clientHeight;
                      const duration = 2000; // Duration for the animation in milliseconds
                      animateAllLines(ctx, coordinates, targetNode, duration);
                    }
                    // Function to animate drawing of all lines synchronously
                    function animateAllLines(ctx, coordinates, target, duration) {
                      const startTime = performance.now();

                      function animationStep(timestamp) {
                        const elapsed = timestamp - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Clear canvas
                        drawNodes(ctx, coordinates, target);
                        coordinates.forEach(({
                          x,
                          y
                        }) => {
                          drawLineSegment(ctx, x, y, target.x, target.y, progress);
                          // Log the traffic event for each line drawn
                          const startNode = coordinates.indexOf(coordinates.find(node => node.x === x && node.y === y)) + 1;
                          const endNode = coordinates.indexOf(coordinates.find(node => node.x === target.x && node.y === target.y)) + 1;
                          logTrafficEvent(startNode, endNode);
                        });
                        if (progress < 1) {
                          animationFrameId = requestAnimationFrame(animationStep);
                        } else {
                          drawNodes(ctx, coordinates, target); // Ensure nodes are drawn after animation
                          setTimeout(() => animateAllLines(ctx, coordinates, target, duration), 1000); // Repeat the animation
                        }
                      }
                      animationFrameId = requestAnimationFrame(animationStep);
                    }
                    // Function to reset the simulation
                    function resetSimulation() {
                      const canvas = document.getElementById('canvas');
                      const ctx = canvas.getContext('2d');
                      ctx.clearRect(0, 0, canvas.width, canvas.height);
                      cancelAnimationFrame(animationFrameId);
                      if (trafficIntervalId) {
                        clearInterval(trafficIntervalId);
                      }
                      trafficAnimations = []; // Clear all traffic animations
                      drawNodes(ctx, coordinates, targetNode); // Redraw nodes after reset
                    }
                    // Function to toggle the visibility of the nodes
                    function toggleNodes() {
                      nodesVisible = !nodesVisible;
                      const canvas = document.getElementById('canvas');
                      const ctx = canvas.getContext('2d');
                      ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
                      drawNodes(ctx, coordinates, targetNode); // Redraw nodes based on visibility
                    }
                    // Function to draw random traffic lines
                    function drawTrafficLine(ctx, startX, startY, endX, endY, duration) {
                      const startTime = performance.now();
                      trafficAnimations.push({
                        startX,
                        startY,
                        endX,
                        endY,
                        startTime,
                        duration,
                        complete: false
                      });
                      // Log the traffic event
                      const startNode = coordinates.indexOf(coordinates.find(node => node.x === startX && node.y === startY)) + 1;
                      const endNode = coordinates.indexOf(coordinates.find(node => node.x === endX && node.y === endY)) + 1;
                      logTrafficEvent(startNode, endNode);
                      if (trafficAnimations.length === 1) { // Start the drawing loop if not already running
                        requestAnimationFrame(() => drawAllTrafficLines(ctx));
                      }
                    }
                    // Function to draw all active traffic lines
                    function drawAllTrafficLines(ctx) {
                      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Clear canvas
                      drawNodes(ctx, coordinates, targetNode);
                      trafficAnimations.forEach(animation => {
                        const {
                          startX,
                          startY,
                          endX,
                          endY,
                          startTime,
                          duration
                        } = animation;
                        const elapsed = performance.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        drawLineSegment(ctx, startX, startY, endX, endY, progress);
                        if (progress >= 1) {
                          animation.complete = true;
                        }
                      });
                      trafficAnimations = trafficAnimations.filter(animation => !animation.complete);
                      if (trafficAnimations.length > 0) {
                        requestAnimationFrame(() => drawAllTrafficLines(ctx));
                      }
                    }
                    // Function to generate random traffic
                    function generateRandomTraffic(ctx) {
                      const randomNode1 = coordinates[Math.floor(Math.random() * coordinates.length)];
                      const randomNode2 = coordinates[Math.floor(Math.random() * coordinates.length)];
                      if (randomNode1 !== randomNode2) {
                        drawTrafficLine(ctx, randomNode1.x, randomNode1.y, randomNode2.x, randomNode2.y, 1000);
                      }
                    }
                    // Function to toggle network traffic
                    function toggleNetworkTraffic() {
                      trafficVisible = !trafficVisible;
                      const canvas = document.getElementById('canvas');
                      const ctx = canvas.getContext('2d');
                      if (trafficVisible) {
                        trafficIntervalId = setInterval(() => generateRandomTraffic(ctx), 250);
                      } else {
                        clearInterval(trafficIntervalId);
                        resetSimulation(); // Clear canvas and reset nodes
                      }
                    }
                    // Initialize the canvas size and draw nodes if visible
                    function initializeCanvas() {
                      const mapElement = document.getElementById('map');
                      const canvas = document.getElementById('canvas');
                      const ctx = canvas.getContext('2d');
                      canvas.width = mapElement.clientWidth;
                      canvas.height = mapElement.clientHeight;
                      drawNodes(ctx, coordinates, targetNode);
                      // Add event listener to handle node clicks and hover
                      canvas.addEventListener('click', (event) => {
                        const rect = canvas.getBoundingClientRect();
                        const clickX = event.clientX - rect.left;
                        const clickY = event.clientY - rect.top;
                        coordinates.forEach(({
                          x,
                          y
                        }) => {
                          if (Math.hypot(x - clickX, y - clickY) < 10) { // Check if click is near a node
                            targetNode = {
                              x,
                              y
                            };
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            drawNodes(ctx, coordinates, targetNode);
                          }
                        });
                      });
                      canvas.addEventListener('mousemove', (event) => {
                        const rect = canvas.getBoundingClientRect();
                        const mouseX = event.clientX - rect.left;
                        const mouseY = event.clientY - rect.top;
                        let cursorChanged = false;
                        coordinates.forEach(({
                          x,
                          y
                        }) => {
                          if (Math.hypot(x - mouseX, y - mouseY) < 10) { // Check if mouse is near a node
                            canvas.style.cursor = 'crosshair';
                            cursorChanged = true;
                          }
                        });
                        if (!cursorChanged) {
                          canvas.style.cursor = 'default';
                        }
                      });
                    }
                    // Adjust canvas size on window resize
                    window.onresize = function() {
                      initializeCanvas();
                    };
                    // Initialize the canvas on page load
                    window.onload = function() {
                      initializeCanvas();
                    };
                  </script>
              </div>
            </section>
          </div>
        </div>
      </div>
    </section>
  </body>
  <script src="../imports/imodal.js"></script>
  <!-- Js for the contact/info/turnitinuk buttons -->
  <script src="../imports/base.js"></script>
  <!-- Js for the header and modal imports -->
</html>